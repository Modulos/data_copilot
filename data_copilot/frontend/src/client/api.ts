/* tslint:disable */
/* eslint-disable */
/**
 * API_NAME
 * API_DESC
 *
 * The version of the OpenAPI document: 0.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Artifact
 */
export interface Artifact {
    /**
     * 
     * @type {string}
     * @memberof Artifact
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Artifact
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof Artifact
     */
    'name': string;
    /**
     * 
     * @type {ArtifactTypes}
     * @memberof Artifact
     */
    'artifact_type': ArtifactTypes;
    /**
     * 
     * @type {string}
     * @memberof Artifact
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Artifact
     */
    'created_at': string;
    /**
     * 
     * @type {ArtifactStatus}
     * @memberof Artifact
     */
    'status'?: ArtifactStatus;
}


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const ArtifactStatus = {
    Active: 'active',
    Deleted: 'deleted'
} as const;

export type ArtifactStatus = typeof ArtifactStatus[keyof typeof ArtifactStatus];


/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const ArtifactTypes = {
    Dataset: 'dataset',
    Model: 'model',
    Config: 'config'
} as const;

export type ArtifactTypes = typeof ArtifactTypes[keyof typeof ArtifactTypes];


/**
 * 
 * @export
 * @interface ArtifactVersion
 */
export interface ArtifactVersion {
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersion
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersion
     */
    'artifact_uri': string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersion
     */
    'artifact_id': string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersion
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersion
     */
    'created_at': string;
    /**
     * 
     * @type {ArtifactVersionStatus}
     * @memberof ArtifactVersion
     */
    'status'?: ArtifactVersionStatus;
}
/**
 * 
 * @export
 * @interface ArtifactVersionFiles
 */
export interface ArtifactVersionFiles {
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionFiles
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionFiles
     */
    'artifact_uri': string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionFiles
     */
    'artifact_id': string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionFiles
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionFiles
     */
    'created_at': string;
    /**
     * 
     * @type {ArtifactVersionStatus}
     * @memberof ArtifactVersionFiles
     */
    'status'?: ArtifactVersionStatus;
    /**
     * 
     * @type {Array<string>}
     * @memberof ArtifactVersionFiles
     */
    'files': Array<string>;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const ArtifactVersionStatus = {
    Latest: 'latest',
    Active: 'active',
    Running: 'running',
    Failed: 'failed',
    Succeeded: 'succeeded',
    Created: 'created',
    Deleted: 'deleted'
} as const;

export type ArtifactVersionStatus = typeof ArtifactVersionStatus[keyof typeof ArtifactVersionStatus];


/**
 * 
 * @export
 * @interface Chat
 */
export interface Chat {
    /**
     * 
     * @type {string}
     * @memberof Chat
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Chat
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Chat
     */
    'artifact_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Chat
     */
    'owner_id': string;
    /**
     * 
     * @type {string}
     * @memberof Chat
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Chat
     */
    'created_at': string;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const ComponentTypes = {
    Table: 'table',
    Text: 'text',
    PlotHist: 'plot_hist',
    PlotBar: 'plot_bar',
    PlotHeatmap: 'plot_heatmap'
} as const;

export type ComponentTypes = typeof ComponentTypes[keyof typeof ComponentTypes];


/**
 * 
 * @export
 * @interface Content
 */
export interface Content {
    /**
     * 
     * @type {string}
     * @memberof Content
     */
    'method_name': string;
    /**
     * 
     * @type {Array<MessageComponents>}
     * @memberof Content
     */
    'components': Array<MessageComponents>;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const ContentTypes = {
    Text: 'text',
    Json: 'json',
    Error: 'error'
} as const;

export type ContentTypes = typeof ContentTypes[keyof typeof ContentTypes];


/**
 * 
 * @export
 * @interface CreateArtifactBase
 */
export interface CreateArtifactBase {
    /**
     * 
     * @type {string}
     * @memberof CreateArtifactBase
     */
    'name': string;
    /**
     * 
     * @type {ArtifactTypes}
     * @memberof CreateArtifactBase
     */
    'artifact_type': ArtifactTypes;
    /**
     * 
     * @type {string}
     * @memberof CreateArtifactBase
     */
    'description'?: string;
}


/**
 * 
 * @export
 * @interface CreateGroup
 */
export interface CreateGroup {
    /**
     * 
     * @type {string}
     * @memberof CreateGroup
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroup
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateGroup
     */
    'is_admin'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateUser
 */
export interface CreateUser {
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'company'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'password': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateUser
     */
    'is_active'?: boolean;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof Group
     */
    'is_admin': boolean;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface GroupList
 */
export interface GroupList {
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupList
     */
    'groups': Array<string>;
}
/**
 * 
 * @export
 * @interface GroupMemberships
 */
export interface GroupMemberships {
    /**
     * 
     * @type {string}
     * @memberof GroupMemberships
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GroupMemberships
     */
    'group_id': string;
    /**
     * 
     * @type {string}
     * @memberof GroupMemberships
     */
    'member_id': string;
    /**
     * 
     * @type {Group}
     * @memberof GroupMemberships
     */
    'group': Group;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface LocationInner
 */
export interface LocationInner {
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {Content}
     * @memberof Message
     */
    'content'?: Content;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'chat_id': string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'artifact_version_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'sender_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    'system_generated'?: boolean;
    /**
     * 
     * @type {ContentTypes}
     * @memberof Message
     */
    'content_type'?: ContentTypes;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface MessageComponents
 */
export interface MessageComponents {
    /**
     * 
     * @type {ComponentTypes}
     * @memberof MessageComponents
     */
    'type': ComponentTypes;
    /**
     * 
     * @type {string}
     * @memberof MessageComponents
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageComponents
     */
    'description'?: string;
    /**
     * 
     * @type {MessageComponentsConfigs}
     * @memberof MessageComponents
     */
    'config'?: MessageComponentsConfigs;
    /**
     * 
     * @type {object}
     * @memberof MessageComponents
     */
    'data'?: object;
}


/**
 * 
 * @export
 * @interface MessageComponentsConfigs
 */
export interface MessageComponentsConfigs {
    /**
     * 
     * @type {boolean}
     * @memberof MessageComponentsConfigs
     */
    'show_title'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MessageComponentsConfigs
     */
    'show_description'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageComponentsConfigs
     */
    'highlight_columns'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof MessageComponentsConfigs
     */
    'highlight_values_from_table'?: boolean;
}
/**
 * 
 * @export
 * @interface MessageJsonContent
 */
export interface MessageJsonContent {
    /**
     * 
     * @type {string}
     * @memberof MessageJsonContent
     */
    'method_name': string;
    /**
     * 
     * @type {Array<MessageComponents>}
     * @memberof MessageJsonContent
     */
    'components': Array<MessageComponents>;
}
/**
 * 
 * @export
 * @interface MessagesResponse
 */
export interface MessagesResponse {
    /**
     * 
     * @type {MessagesResponseMetadata}
     * @memberof MessagesResponse
     */
    'metadata': MessagesResponseMetadata;
    /**
     * 
     * @type {Array<Message>}
     * @memberof MessagesResponse
     */
    'data': Array<Message>;
}
/**
 * 
 * @export
 * @interface MessagesResponseMetadata
 */
export interface MessagesResponseMetadata {
    /**
     * 
     * @type {number}
     * @memberof MessagesResponseMetadata
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof MessagesResponseMetadata
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'token_type': string;
}
/**
 * 
 * @export
 * @interface UpdateArtifact
 */
export interface UpdateArtifact {
    /**
     * 
     * @type {string}
     * @memberof UpdateArtifact
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateArtifact
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UpdateChat
 */
export interface UpdateChat {
    /**
     * 
     * @type {string}
     * @memberof UpdateChat
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateChat
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'sso'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'sso_provider'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'company'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {Array<GroupMemberships>}
     * @memberof User
     */
    'groups'?: Array<GroupMemberships>;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a group. Returns None.
         * @summary Delete Groups
         * @param {string} groupName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupsApiAdminGroupsDelete: async (groupName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists('deleteGroupsApiAdminGroupsDelete', 'groupName', groupName)
            const localVarPath = `/api/admin/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (groupName !== undefined) {
                localVarQueryParameter['group_name'] = groupName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Users
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersApiAdminUsersUserIdDelete: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUsersApiAdminUsersUserIdDelete', 'userId', userId)
            const localVarPath = `/api/admin/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Users Group
         * @param {string} userId 
         * @param {string} groupName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersGroupApiAdminUsersUserIdGroupDelete: async (userId: string, groupName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUsersGroupApiAdminUsersUserIdGroupDelete', 'userId', userId)
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists('deleteUsersGroupApiAdminUsersUserIdGroupDelete', 'groupName', groupName)
            const localVarPath = `/api/admin/users/{user_id}/group`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (groupName !== undefined) {
                localVarQueryParameter['group_name'] = groupName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all the groups.  Args:     skip (int, optional): The number of groups to skip. Defaults to 0.     limit (int, optional): The number of groups to return. Defaults to 100.  Returns:     list[Group]: A list of groups
         * @summary Get Groups
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsApiAdminGroupsGet: async (skip?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Users
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersApiAdminUsersGet: async (skip?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Users Query Email
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersQueryEmailApiAdminUsersQueryEmailGet: async (email: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('getUsersQueryEmailApiAdminUsersQueryEmailGet', 'email', email)
            const localVarPath = `/api/admin/users/query/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Users Userid
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUseridApiAdminUsersUserIdGet: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersUseridApiAdminUsersUserIdGet', 'userId', userId)
            const localVarPath = `/api/admin/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new group with name and description. Returns the created group.  Args:     group (CreateGroup): The group to create  Returns:     Group: The created group
         * @summary Post Groups
         * @param {CreateGroup} createGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroupsApiAdminGroupsPost: async (createGroup: CreateGroup, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGroup' is not null or undefined
            assertParamExists('postGroupsApiAdminGroupsPost', 'createGroup', createGroup)
            const localVarPath = `/api/admin/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Users
         * @param {CreateUser} createUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersApiAdminUsersPost: async (createUser: CreateUser, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUser' is not null or undefined
            assertParamExists('postUsersApiAdminUsersPost', 'createUser', createUser)
            const localVarPath = `/api/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a user to a group.
         * @summary Post Users Group
         * @param {string} userId 
         * @param {string} email 
         * @param {string} groupName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersGroupApiAdminUsersUserIdGroupPost: async (userId: string, email: string, groupName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('postUsersGroupApiAdminUsersUserIdGroupPost', 'userId', userId)
            // verify required parameter 'email' is not null or undefined
            assertParamExists('postUsersGroupApiAdminUsersUserIdGroupPost', 'email', email)
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists('postUsersGroupApiAdminUsersUserIdGroupPost', 'groupName', groupName)
            const localVarPath = `/api/admin/users/{user_id}/group`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (groupName !== undefined) {
                localVarQueryParameter['group_name'] = groupName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a group. Returns None.
         * @summary Delete Groups
         * @param {string} groupName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupsApiAdminGroupsDelete(groupName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupsApiAdminGroupsDelete(groupName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Users
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsersApiAdminUsersUserIdDelete(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUsersApiAdminUsersUserIdDelete(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Users Group
         * @param {string} userId 
         * @param {string} groupName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsersGroupApiAdminUsersUserIdGroupDelete(userId: string, groupName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUsersGroupApiAdminUsersUserIdGroupDelete(userId, groupName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all the groups.  Args:     skip (int, optional): The number of groups to skip. Defaults to 0.     limit (int, optional): The number of groups to return. Defaults to 100.  Returns:     list[Group]: A list of groups
         * @summary Get Groups
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupsApiAdminGroupsGet(skip?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Group>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupsApiAdminGroupsGet(skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Users
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersApiAdminUsersGet(skip?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersApiAdminUsersGet(skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Users Query Email
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersQueryEmailApiAdminUsersQueryEmailGet(email: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersQueryEmailApiAdminUsersQueryEmailGet(email, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Users Userid
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersUseridApiAdminUsersUserIdGet(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersUseridApiAdminUsersUserIdGet(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new group with name and description. Returns the created group.  Args:     group (CreateGroup): The group to create  Returns:     Group: The created group
         * @summary Post Groups
         * @param {CreateGroup} createGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postGroupsApiAdminGroupsPost(createGroup: CreateGroup, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postGroupsApiAdminGroupsPost(createGroup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Users
         * @param {CreateUser} createUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersApiAdminUsersPost(createUser: CreateUser, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsersApiAdminUsersPost(createUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a user to a group.
         * @summary Post Users Group
         * @param {string} userId 
         * @param {string} email 
         * @param {string} groupName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersGroupApiAdminUsersUserIdGroupPost(userId: string, email: string, groupName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsersGroupApiAdminUsersUserIdGroupPost(userId, email, groupName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * Delete a group. Returns None.
         * @summary Delete Groups
         * @param {string} groupName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupsApiAdminGroupsDelete(groupName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroupsApiAdminGroupsDelete(groupName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Users
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersApiAdminUsersUserIdDelete(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUsersApiAdminUsersUserIdDelete(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Users Group
         * @param {string} userId 
         * @param {string} groupName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersGroupApiAdminUsersUserIdGroupDelete(userId: string, groupName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUsersGroupApiAdminUsersUserIdGroupDelete(userId, groupName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all the groups.  Args:     skip (int, optional): The number of groups to skip. Defaults to 0.     limit (int, optional): The number of groups to return. Defaults to 100.  Returns:     list[Group]: A list of groups
         * @summary Get Groups
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsApiAdminGroupsGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<Group>> {
            return localVarFp.getGroupsApiAdminGroupsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Users
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersApiAdminUsersGet(skip?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.getUsersApiAdminUsersGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Users Query Email
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersQueryEmailApiAdminUsersQueryEmailGet(email: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUsersQueryEmailApiAdminUsersQueryEmailGet(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Users Userid
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUseridApiAdminUsersUserIdGet(userId: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUsersUseridApiAdminUsersUserIdGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new group with name and description. Returns the created group.  Args:     group (CreateGroup): The group to create  Returns:     Group: The created group
         * @summary Post Groups
         * @param {CreateGroup} createGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroupsApiAdminGroupsPost(createGroup: CreateGroup, options?: any): AxiosPromise<any> {
            return localVarFp.postGroupsApiAdminGroupsPost(createGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Users
         * @param {CreateUser} createUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersApiAdminUsersPost(createUser: CreateUser, options?: any): AxiosPromise<User> {
            return localVarFp.postUsersApiAdminUsersPost(createUser, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a user to a group.
         * @summary Post Users Group
         * @param {string} userId 
         * @param {string} email 
         * @param {string} groupName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersGroupApiAdminUsersUserIdGroupPost(userId: string, email: string, groupName: string, options?: any): AxiosPromise<any> {
            return localVarFp.postUsersGroupApiAdminUsersUserIdGroupPost(userId, email, groupName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * Delete a group. Returns None.
     * @summary Delete Groups
     * @param {string} groupName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteGroupsApiAdminGroupsDelete(groupName: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteGroupsApiAdminGroupsDelete(groupName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Users
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteUsersApiAdminUsersUserIdDelete(userId: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteUsersApiAdminUsersUserIdDelete(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Users Group
     * @param {string} userId 
     * @param {string} groupName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteUsersGroupApiAdminUsersUserIdGroupDelete(userId: string, groupName: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteUsersGroupApiAdminUsersUserIdGroupDelete(userId, groupName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all the groups.  Args:     skip (int, optional): The number of groups to skip. Defaults to 0.     limit (int, optional): The number of groups to return. Defaults to 100.  Returns:     list[Group]: A list of groups
     * @summary Get Groups
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getGroupsApiAdminGroupsGet(skip?: number, limit?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getGroupsApiAdminGroupsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Users
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getUsersApiAdminUsersGet(skip?: number, limit?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getUsersApiAdminUsersGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Users Query Email
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getUsersQueryEmailApiAdminUsersQueryEmailGet(email: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getUsersQueryEmailApiAdminUsersQueryEmailGet(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Users Userid
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getUsersUseridApiAdminUsersUserIdGet(userId: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getUsersUseridApiAdminUsersUserIdGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new group with name and description. Returns the created group.  Args:     group (CreateGroup): The group to create  Returns:     Group: The created group
     * @summary Post Groups
     * @param {CreateGroup} createGroup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public postGroupsApiAdminGroupsPost(createGroup: CreateGroup, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).postGroupsApiAdminGroupsPost(createGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Users
     * @param {CreateUser} createUser 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public postUsersApiAdminUsersPost(createUser: CreateUser, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).postUsersApiAdminUsersPost(createUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a user to a group.
     * @summary Post Users Group
     * @param {string} userId 
     * @param {string} email 
     * @param {string} groupName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public postUsersGroupApiAdminUsersUserIdGroupPost(userId: string, email: string, groupName: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).postUsersGroupApiAdminUsersUserIdGroupPost(userId, email, groupName, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ArtifactApi - axios parameter creator
 * @export
 */
export const ArtifactApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Soft deletes the artifact with the given ID.  Args:     artifact (Artifact): The artifact.     db (Session): Database session.  Raises:     HTTPException: If the artifact was not found.
         * @summary Delete Artifact Id Artifactid
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactIdArtifactidApiArtifactsArtifactIdDelete: async (artifactId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('deleteArtifactIdArtifactidApiArtifactsArtifactIdDelete', 'artifactId', artifactId)
            const localVarPath = `/api/artifacts/{artifact_id}`
                .replace(`{${"artifact_id"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the artifacts owned by the current user and apply filters if any.  Args:     current_user (User): The current user     artifact_type (ArtifactTypes): The type of the artifact to filter on.     status (ArtifactStatus): Artifact\'s status     db (Session): Database session.  Returns:     list[Artifact]: List of artifacts.
         * @summary Get Artifacts
         * @param {ArtifactTypes} [artifactType] 
         * @param {ArtifactStatus} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsApiArtifactsGet: async (artifactType?: ArtifactTypes, status?: ArtifactStatus, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/artifacts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (artifactType !== undefined) {
                localVarQueryParameter['artifact_type'] = artifactType;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an artifact by id. Only the current user can access the artifact.  Args:     artifact (Artifact): The artifact  Returns:     Artifact: The artifact.
         * @summary Get Artifacts Id Artifactid
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsIdArtifactidApiArtifactsArtifactIdGet: async (artifactId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getArtifactsIdArtifactidApiArtifactsArtifactIdGet', 'artifactId', artifactId)
            const localVarPath = `/api/artifacts/{artifact_id}`
                .replace(`{${"artifact_id"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of artifact versions for a given artifact. The list is ordered by creation date. The list can be filtered by status. The default status is \"latest\", which returns the latest artifact version ignoring the status. Only the current user can access the artifact.  Args:     artifact (Artifact): The artifact     status (ArtifactVersionStatus): The status of the artifact version     limit (int): The number of artifact versions to return. Default is 1.     db (Session): Database session.  Returns:     list[ArtifactVersion]: The list of artifact versions
         * @summary Get Artifacts Id Artifactid Versions
         * @param {string} artifactId 
         * @param {ArtifactVersionStatus} [status] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsIdArtifactidVersionsApiArtifactsArtifactIdVersionsGet: async (artifactId: string, status?: ArtifactVersionStatus, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getArtifactsIdArtifactidVersionsApiArtifactsArtifactIdVersionsGet', 'artifactId', artifactId)
            const localVarPath = `/api/artifacts/{artifact_id}/versions`
                .replace(`{${"artifact_id"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an artifact version by artifact and artifact version id. Only the current user can access the artifact.  Args:     artifact (Artifact): The artifact     artifact_version (ArtifactVersion): The artifact version  Returns:     ArtifactVersionFiles: The artifact version with the list of files
         * @summary Get Artifacts Id Artifactid Versions Artifactversionid
         * @param {string} artifactId 
         * @param {string} artifactVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsIdArtifactidVersionsArtifactversionidApiArtifactsArtifactIdVersionsArtifactVersionIdGet: async (artifactId: string, artifactVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getArtifactsIdArtifactidVersionsArtifactversionidApiArtifactsArtifactIdVersionsArtifactVersionIdGet', 'artifactId', artifactId)
            // verify required parameter 'artifactVersionId' is not null or undefined
            assertParamExists('getArtifactsIdArtifactidVersionsArtifactversionidApiArtifactsArtifactIdVersionsArtifactVersionIdGet', 'artifactVersionId', artifactVersionId)
            const localVarPath = `/api/artifacts/{artifact_id}/versions/{artifact_version_id}`
                .replace(`{${"artifact_id"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"artifact_version_id"}}`, encodeURIComponent(String(artifactVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of files in the given artifact version. Only the current user can access the artifact and the artifact version.  Args:     file_name (str): The name of the file     artifact (Artifact): The artifact     artifact_version (ArtifactVersion): The artifact version  Returns:     str: The SAS URL for the file
         * @summary Get Artifacts Id Artifactid Versions Artifactversionid Files Filename
         * @param {string} fileName 
         * @param {string} artifactId 
         * @param {string} artifactVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsIdArtifactidVersionsArtifactversionidFilesFilenameApiArtifactsArtifactIdVersionsArtifactVersionIdFilesFileNameGet: async (fileName: string, artifactId: string, artifactVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getArtifactsIdArtifactidVersionsArtifactversionidFilesFilenameApiArtifactsArtifactIdVersionsArtifactVersionIdFilesFileNameGet', 'fileName', fileName)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getArtifactsIdArtifactidVersionsArtifactversionidFilesFilenameApiArtifactsArtifactIdVersionsArtifactVersionIdFilesFileNameGet', 'artifactId', artifactId)
            // verify required parameter 'artifactVersionId' is not null or undefined
            assertParamExists('getArtifactsIdArtifactidVersionsArtifactversionidFilesFilenameApiArtifactsArtifactIdVersionsArtifactVersionIdFilesFileNameGet', 'artifactVersionId', artifactVersionId)
            const localVarPath = `/api/artifacts/{artifact_id}/versions/{artifact_version_id}/files/{file_name}`
                .replace(`{${"file_name"}}`, encodeURIComponent(String(fileName)))
                .replace(`{${"artifact_id"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"artifact_version_id"}}`, encodeURIComponent(String(artifactVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates artifact\'s attributes like name, description, etc.  Args:     artifact_update (UpdateArtifact): The updates.     artifact (Artifact): The artifact to be updated.     db (Session): Database session.  Raises:     HTTPException: If the artifact was not found, or it has status \"deleted\".  Returns (Session): Updated artifact.
         * @summary Patch Artifact Id Artifactid
         * @param {string} artifactId 
         * @param {UpdateArtifact} updateArtifact 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchArtifactIdArtifactidApiArtifactsArtifactIdPatch: async (artifactId: string, updateArtifact: UpdateArtifact, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('patchArtifactIdArtifactidApiArtifactsArtifactIdPatch', 'artifactId', artifactId)
            // verify required parameter 'updateArtifact' is not null or undefined
            assertParamExists('patchArtifactIdArtifactidApiArtifactsArtifactIdPatch', 'updateArtifact', updateArtifact)
            const localVarPath = `/api/artifacts/{artifact_id}`
                .replace(`{${"artifact_id"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateArtifact, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new artifact of a given type. The artifact is created by the current user. Only the current user can access the artifact. The artifact is created with status \"active\".  Args:     artifact (CreateArtifactBase): The artifact to be created     current_user (User): The current user     db (Session): Database session.  Returns:     Artifact: The created artifact
         * @summary Post Artifact
         * @param {CreateArtifactBase} createArtifactBase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postArtifactApiArtifactsPost: async (createArtifactBase: CreateArtifactBase, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createArtifactBase' is not null or undefined
            assertParamExists('postArtifactApiArtifactsPost', 'createArtifactBase', createArtifactBase)
            const localVarPath = `/api/artifacts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createArtifactBase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a new artifact version for a given artifact. Only the current user can access the artifact. The artifact version is created with status \"succeeded\".  Args:     file (UploadFile): The file to upload     artifact (Artifact): The artifact     db (Session): Database session.  Returns:     ArtifactVersion: The artifact version
         * @summary Post Artifacts Id Artifactid Versions
         * @param {string} artifactId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postArtifactsIdArtifactidVersionsApiArtifactsArtifactIdVersionsPost: async (artifactId: string, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('postArtifactsIdArtifactidVersionsApiArtifactsArtifactIdVersionsPost', 'artifactId', artifactId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('postArtifactsIdArtifactidVersionsApiArtifactsArtifactIdVersionsPost', 'file', file)
            const localVarPath = `/api/artifacts/{artifact_id}/versions`
                .replace(`{${"artifact_id"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactApi - functional programming interface
 * @export
 */
export const ArtifactApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtifactApiAxiosParamCreator(configuration)
    return {
        /**
         * Soft deletes the artifact with the given ID.  Args:     artifact (Artifact): The artifact.     db (Session): Database session.  Raises:     HTTPException: If the artifact was not found.
         * @summary Delete Artifact Id Artifactid
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArtifactIdArtifactidApiArtifactsArtifactIdDelete(artifactId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArtifactIdArtifactidApiArtifactsArtifactIdDelete(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all the artifacts owned by the current user and apply filters if any.  Args:     current_user (User): The current user     artifact_type (ArtifactTypes): The type of the artifact to filter on.     status (ArtifactStatus): Artifact\'s status     db (Session): Database session.  Returns:     list[Artifact]: List of artifacts.
         * @summary Get Artifacts
         * @param {ArtifactTypes} [artifactType] 
         * @param {ArtifactStatus} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifactsApiArtifactsGet(artifactType?: ArtifactTypes, status?: ArtifactStatus, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Artifact>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifactsApiArtifactsGet(artifactType, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an artifact by id. Only the current user can access the artifact.  Args:     artifact (Artifact): The artifact  Returns:     Artifact: The artifact.
         * @summary Get Artifacts Id Artifactid
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifactsIdArtifactidApiArtifactsArtifactIdGet(artifactId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Artifact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifactsIdArtifactidApiArtifactsArtifactIdGet(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of artifact versions for a given artifact. The list is ordered by creation date. The list can be filtered by status. The default status is \"latest\", which returns the latest artifact version ignoring the status. Only the current user can access the artifact.  Args:     artifact (Artifact): The artifact     status (ArtifactVersionStatus): The status of the artifact version     limit (int): The number of artifact versions to return. Default is 1.     db (Session): Database session.  Returns:     list[ArtifactVersion]: The list of artifact versions
         * @summary Get Artifacts Id Artifactid Versions
         * @param {string} artifactId 
         * @param {ArtifactVersionStatus} [status] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifactsIdArtifactidVersionsApiArtifactsArtifactIdVersionsGet(artifactId: string, status?: ArtifactVersionStatus, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactVersion>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifactsIdArtifactidVersionsApiArtifactsArtifactIdVersionsGet(artifactId, status, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an artifact version by artifact and artifact version id. Only the current user can access the artifact.  Args:     artifact (Artifact): The artifact     artifact_version (ArtifactVersion): The artifact version  Returns:     ArtifactVersionFiles: The artifact version with the list of files
         * @summary Get Artifacts Id Artifactid Versions Artifactversionid
         * @param {string} artifactId 
         * @param {string} artifactVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifactsIdArtifactidVersionsArtifactversionidApiArtifactsArtifactIdVersionsArtifactVersionIdGet(artifactId: string, artifactVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactVersionFiles>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifactsIdArtifactidVersionsArtifactversionidApiArtifactsArtifactIdVersionsArtifactVersionIdGet(artifactId, artifactVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the list of files in the given artifact version. Only the current user can access the artifact and the artifact version.  Args:     file_name (str): The name of the file     artifact (Artifact): The artifact     artifact_version (ArtifactVersion): The artifact version  Returns:     str: The SAS URL for the file
         * @summary Get Artifacts Id Artifactid Versions Artifactversionid Files Filename
         * @param {string} fileName 
         * @param {string} artifactId 
         * @param {string} artifactVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifactsIdArtifactidVersionsArtifactversionidFilesFilenameApiArtifactsArtifactIdVersionsArtifactVersionIdFilesFileNameGet(fileName: string, artifactId: string, artifactVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifactsIdArtifactidVersionsArtifactversionidFilesFilenameApiArtifactsArtifactIdVersionsArtifactVersionIdFilesFileNameGet(fileName, artifactId, artifactVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates artifact\'s attributes like name, description, etc.  Args:     artifact_update (UpdateArtifact): The updates.     artifact (Artifact): The artifact to be updated.     db (Session): Database session.  Raises:     HTTPException: If the artifact was not found, or it has status \"deleted\".  Returns (Session): Updated artifact.
         * @summary Patch Artifact Id Artifactid
         * @param {string} artifactId 
         * @param {UpdateArtifact} updateArtifact 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchArtifactIdArtifactidApiArtifactsArtifactIdPatch(artifactId: string, updateArtifact: UpdateArtifact, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Artifact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchArtifactIdArtifactidApiArtifactsArtifactIdPatch(artifactId, updateArtifact, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new artifact of a given type. The artifact is created by the current user. Only the current user can access the artifact. The artifact is created with status \"active\".  Args:     artifact (CreateArtifactBase): The artifact to be created     current_user (User): The current user     db (Session): Database session.  Returns:     Artifact: The created artifact
         * @summary Post Artifact
         * @param {CreateArtifactBase} createArtifactBase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postArtifactApiArtifactsPost(createArtifactBase: CreateArtifactBase, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Artifact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postArtifactApiArtifactsPost(createArtifactBase, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload a new artifact version for a given artifact. Only the current user can access the artifact. The artifact version is created with status \"succeeded\".  Args:     file (UploadFile): The file to upload     artifact (Artifact): The artifact     db (Session): Database session.  Returns:     ArtifactVersion: The artifact version
         * @summary Post Artifacts Id Artifactid Versions
         * @param {string} artifactId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postArtifactsIdArtifactidVersionsApiArtifactsArtifactIdVersionsPost(artifactId: string, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postArtifactsIdArtifactidVersionsApiArtifactsArtifactIdVersionsPost(artifactId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArtifactApi - factory interface
 * @export
 */
export const ArtifactApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtifactApiFp(configuration)
    return {
        /**
         * Soft deletes the artifact with the given ID.  Args:     artifact (Artifact): The artifact.     db (Session): Database session.  Raises:     HTTPException: If the artifact was not found.
         * @summary Delete Artifact Id Artifactid
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactIdArtifactidApiArtifactsArtifactIdDelete(artifactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteArtifactIdArtifactidApiArtifactsArtifactIdDelete(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the artifacts owned by the current user and apply filters if any.  Args:     current_user (User): The current user     artifact_type (ArtifactTypes): The type of the artifact to filter on.     status (ArtifactStatus): Artifact\'s status     db (Session): Database session.  Returns:     list[Artifact]: List of artifacts.
         * @summary Get Artifacts
         * @param {ArtifactTypes} [artifactType] 
         * @param {ArtifactStatus} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsApiArtifactsGet(artifactType?: ArtifactTypes, status?: ArtifactStatus, options?: any): AxiosPromise<Array<Artifact>> {
            return localVarFp.getArtifactsApiArtifactsGet(artifactType, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an artifact by id. Only the current user can access the artifact.  Args:     artifact (Artifact): The artifact  Returns:     Artifact: The artifact.
         * @summary Get Artifacts Id Artifactid
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsIdArtifactidApiArtifactsArtifactIdGet(artifactId: string, options?: any): AxiosPromise<Artifact> {
            return localVarFp.getArtifactsIdArtifactidApiArtifactsArtifactIdGet(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of artifact versions for a given artifact. The list is ordered by creation date. The list can be filtered by status. The default status is \"latest\", which returns the latest artifact version ignoring the status. Only the current user can access the artifact.  Args:     artifact (Artifact): The artifact     status (ArtifactVersionStatus): The status of the artifact version     limit (int): The number of artifact versions to return. Default is 1.     db (Session): Database session.  Returns:     list[ArtifactVersion]: The list of artifact versions
         * @summary Get Artifacts Id Artifactid Versions
         * @param {string} artifactId 
         * @param {ArtifactVersionStatus} [status] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsIdArtifactidVersionsApiArtifactsArtifactIdVersionsGet(artifactId: string, status?: ArtifactVersionStatus, limit?: number, options?: any): AxiosPromise<Array<ArtifactVersion>> {
            return localVarFp.getArtifactsIdArtifactidVersionsApiArtifactsArtifactIdVersionsGet(artifactId, status, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an artifact version by artifact and artifact version id. Only the current user can access the artifact.  Args:     artifact (Artifact): The artifact     artifact_version (ArtifactVersion): The artifact version  Returns:     ArtifactVersionFiles: The artifact version with the list of files
         * @summary Get Artifacts Id Artifactid Versions Artifactversionid
         * @param {string} artifactId 
         * @param {string} artifactVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsIdArtifactidVersionsArtifactversionidApiArtifactsArtifactIdVersionsArtifactVersionIdGet(artifactId: string, artifactVersionId: string, options?: any): AxiosPromise<ArtifactVersionFiles> {
            return localVarFp.getArtifactsIdArtifactidVersionsArtifactversionidApiArtifactsArtifactIdVersionsArtifactVersionIdGet(artifactId, artifactVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of files in the given artifact version. Only the current user can access the artifact and the artifact version.  Args:     file_name (str): The name of the file     artifact (Artifact): The artifact     artifact_version (ArtifactVersion): The artifact version  Returns:     str: The SAS URL for the file
         * @summary Get Artifacts Id Artifactid Versions Artifactversionid Files Filename
         * @param {string} fileName 
         * @param {string} artifactId 
         * @param {string} artifactVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsIdArtifactidVersionsArtifactversionidFilesFilenameApiArtifactsArtifactIdVersionsArtifactVersionIdFilesFileNameGet(fileName: string, artifactId: string, artifactVersionId: string, options?: any): AxiosPromise<any> {
            return localVarFp.getArtifactsIdArtifactidVersionsArtifactversionidFilesFilenameApiArtifactsArtifactIdVersionsArtifactVersionIdFilesFileNameGet(fileName, artifactId, artifactVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates artifact\'s attributes like name, description, etc.  Args:     artifact_update (UpdateArtifact): The updates.     artifact (Artifact): The artifact to be updated.     db (Session): Database session.  Raises:     HTTPException: If the artifact was not found, or it has status \"deleted\".  Returns (Session): Updated artifact.
         * @summary Patch Artifact Id Artifactid
         * @param {string} artifactId 
         * @param {UpdateArtifact} updateArtifact 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchArtifactIdArtifactidApiArtifactsArtifactIdPatch(artifactId: string, updateArtifact: UpdateArtifact, options?: any): AxiosPromise<Artifact> {
            return localVarFp.patchArtifactIdArtifactidApiArtifactsArtifactIdPatch(artifactId, updateArtifact, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new artifact of a given type. The artifact is created by the current user. Only the current user can access the artifact. The artifact is created with status \"active\".  Args:     artifact (CreateArtifactBase): The artifact to be created     current_user (User): The current user     db (Session): Database session.  Returns:     Artifact: The created artifact
         * @summary Post Artifact
         * @param {CreateArtifactBase} createArtifactBase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postArtifactApiArtifactsPost(createArtifactBase: CreateArtifactBase, options?: any): AxiosPromise<Artifact> {
            return localVarFp.postArtifactApiArtifactsPost(createArtifactBase, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a new artifact version for a given artifact. Only the current user can access the artifact. The artifact version is created with status \"succeeded\".  Args:     file (UploadFile): The file to upload     artifact (Artifact): The artifact     db (Session): Database session.  Returns:     ArtifactVersion: The artifact version
         * @summary Post Artifacts Id Artifactid Versions
         * @param {string} artifactId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postArtifactsIdArtifactidVersionsApiArtifactsArtifactIdVersionsPost(artifactId: string, file: File, options?: any): AxiosPromise<ArtifactVersion> {
            return localVarFp.postArtifactsIdArtifactidVersionsApiArtifactsArtifactIdVersionsPost(artifactId, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtifactApi - object-oriented interface
 * @export
 * @class ArtifactApi
 * @extends {BaseAPI}
 */
export class ArtifactApi extends BaseAPI {
    /**
     * Soft deletes the artifact with the given ID.  Args:     artifact (Artifact): The artifact.     db (Session): Database session.  Raises:     HTTPException: If the artifact was not found.
     * @summary Delete Artifact Id Artifactid
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public deleteArtifactIdArtifactidApiArtifactsArtifactIdDelete(artifactId: string, options?: AxiosRequestConfig) {
        return ArtifactApiFp(this.configuration).deleteArtifactIdArtifactidApiArtifactsArtifactIdDelete(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the artifacts owned by the current user and apply filters if any.  Args:     current_user (User): The current user     artifact_type (ArtifactTypes): The type of the artifact to filter on.     status (ArtifactStatus): Artifact\'s status     db (Session): Database session.  Returns:     list[Artifact]: List of artifacts.
     * @summary Get Artifacts
     * @param {ArtifactTypes} [artifactType] 
     * @param {ArtifactStatus} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getArtifactsApiArtifactsGet(artifactType?: ArtifactTypes, status?: ArtifactStatus, options?: AxiosRequestConfig) {
        return ArtifactApiFp(this.configuration).getArtifactsApiArtifactsGet(artifactType, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an artifact by id. Only the current user can access the artifact.  Args:     artifact (Artifact): The artifact  Returns:     Artifact: The artifact.
     * @summary Get Artifacts Id Artifactid
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getArtifactsIdArtifactidApiArtifactsArtifactIdGet(artifactId: string, options?: AxiosRequestConfig) {
        return ArtifactApiFp(this.configuration).getArtifactsIdArtifactidApiArtifactsArtifactIdGet(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of artifact versions for a given artifact. The list is ordered by creation date. The list can be filtered by status. The default status is \"latest\", which returns the latest artifact version ignoring the status. Only the current user can access the artifact.  Args:     artifact (Artifact): The artifact     status (ArtifactVersionStatus): The status of the artifact version     limit (int): The number of artifact versions to return. Default is 1.     db (Session): Database session.  Returns:     list[ArtifactVersion]: The list of artifact versions
     * @summary Get Artifacts Id Artifactid Versions
     * @param {string} artifactId 
     * @param {ArtifactVersionStatus} [status] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getArtifactsIdArtifactidVersionsApiArtifactsArtifactIdVersionsGet(artifactId: string, status?: ArtifactVersionStatus, limit?: number, options?: AxiosRequestConfig) {
        return ArtifactApiFp(this.configuration).getArtifactsIdArtifactidVersionsApiArtifactsArtifactIdVersionsGet(artifactId, status, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an artifact version by artifact and artifact version id. Only the current user can access the artifact.  Args:     artifact (Artifact): The artifact     artifact_version (ArtifactVersion): The artifact version  Returns:     ArtifactVersionFiles: The artifact version with the list of files
     * @summary Get Artifacts Id Artifactid Versions Artifactversionid
     * @param {string} artifactId 
     * @param {string} artifactVersionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getArtifactsIdArtifactidVersionsArtifactversionidApiArtifactsArtifactIdVersionsArtifactVersionIdGet(artifactId: string, artifactVersionId: string, options?: AxiosRequestConfig) {
        return ArtifactApiFp(this.configuration).getArtifactsIdArtifactidVersionsArtifactversionidApiArtifactsArtifactIdVersionsArtifactVersionIdGet(artifactId, artifactVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the list of files in the given artifact version. Only the current user can access the artifact and the artifact version.  Args:     file_name (str): The name of the file     artifact (Artifact): The artifact     artifact_version (ArtifactVersion): The artifact version  Returns:     str: The SAS URL for the file
     * @summary Get Artifacts Id Artifactid Versions Artifactversionid Files Filename
     * @param {string} fileName 
     * @param {string} artifactId 
     * @param {string} artifactVersionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getArtifactsIdArtifactidVersionsArtifactversionidFilesFilenameApiArtifactsArtifactIdVersionsArtifactVersionIdFilesFileNameGet(fileName: string, artifactId: string, artifactVersionId: string, options?: AxiosRequestConfig) {
        return ArtifactApiFp(this.configuration).getArtifactsIdArtifactidVersionsArtifactversionidFilesFilenameApiArtifactsArtifactIdVersionsArtifactVersionIdFilesFileNameGet(fileName, artifactId, artifactVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates artifact\'s attributes like name, description, etc.  Args:     artifact_update (UpdateArtifact): The updates.     artifact (Artifact): The artifact to be updated.     db (Session): Database session.  Raises:     HTTPException: If the artifact was not found, or it has status \"deleted\".  Returns (Session): Updated artifact.
     * @summary Patch Artifact Id Artifactid
     * @param {string} artifactId 
     * @param {UpdateArtifact} updateArtifact 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public patchArtifactIdArtifactidApiArtifactsArtifactIdPatch(artifactId: string, updateArtifact: UpdateArtifact, options?: AxiosRequestConfig) {
        return ArtifactApiFp(this.configuration).patchArtifactIdArtifactidApiArtifactsArtifactIdPatch(artifactId, updateArtifact, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new artifact of a given type. The artifact is created by the current user. Only the current user can access the artifact. The artifact is created with status \"active\".  Args:     artifact (CreateArtifactBase): The artifact to be created     current_user (User): The current user     db (Session): Database session.  Returns:     Artifact: The created artifact
     * @summary Post Artifact
     * @param {CreateArtifactBase} createArtifactBase 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public postArtifactApiArtifactsPost(createArtifactBase: CreateArtifactBase, options?: AxiosRequestConfig) {
        return ArtifactApiFp(this.configuration).postArtifactApiArtifactsPost(createArtifactBase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a new artifact version for a given artifact. Only the current user can access the artifact. The artifact version is created with status \"succeeded\".  Args:     file (UploadFile): The file to upload     artifact (Artifact): The artifact     db (Session): Database session.  Returns:     ArtifactVersion: The artifact version
     * @summary Post Artifacts Id Artifactid Versions
     * @param {string} artifactId 
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public postArtifactsIdArtifactidVersionsApiArtifactsArtifactIdVersionsPost(artifactId: string, file: File, options?: AxiosRequestConfig) {
        return ArtifactApiFp(this.configuration).postArtifactsIdArtifactidVersionsApiArtifactsArtifactIdVersionsPost(artifactId, file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenicationApi - axios parameter creator
 * @export
 */
export const AuthenicationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OAuth2 compatible token login, get an access token for future requests.  Args:     form_data (OAuth2PasswordRequestForm): The form data containing the                                            username and password  Returns:     Token: The access token
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginForAccessTokenApiTokenPost: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('loginForAccessTokenApiTokenPost', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('loginForAccessTokenApiTokenPost', 'password', password)
            const localVarPath = `/api/token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh the access token. This is used to refresh the access token before it expires.  Args:     current_user (User): The current user  Returns:     Token: The access token
         * @summary Refresh Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenApiTokenRefreshPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/token/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenicationApi - functional programming interface
 * @export
 */
export const AuthenicationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenicationApiAxiosParamCreator(configuration)
    return {
        /**
         * OAuth2 compatible token login, get an access token for future requests.  Args:     form_data (OAuth2PasswordRequestForm): The form data containing the                                            username and password  Returns:     Token: The access token
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginForAccessTokenApiTokenPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginForAccessTokenApiTokenPost(username, password, grantType, scope, clientId, clientSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh the access token. This is used to refresh the access token before it expires.  Args:     current_user (User): The current user  Returns:     Token: The access token
         * @summary Refresh Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshTokenApiTokenRefreshPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshTokenApiTokenRefreshPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenicationApi - factory interface
 * @export
 */
export const AuthenicationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenicationApiFp(configuration)
    return {
        /**
         * OAuth2 compatible token login, get an access token for future requests.  Args:     form_data (OAuth2PasswordRequestForm): The form data containing the                                            username and password  Returns:     Token: The access token
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginForAccessTokenApiTokenPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): AxiosPromise<Token> {
            return localVarFp.loginForAccessTokenApiTokenPost(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh the access token. This is used to refresh the access token before it expires.  Args:     current_user (User): The current user  Returns:     Token: The access token
         * @summary Refresh Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenApiTokenRefreshPost(options?: any): AxiosPromise<Token> {
            return localVarFp.refreshTokenApiTokenRefreshPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenicationApi - object-oriented interface
 * @export
 * @class AuthenicationApi
 * @extends {BaseAPI}
 */
export class AuthenicationApi extends BaseAPI {
    /**
     * OAuth2 compatible token login, get an access token for future requests.  Args:     form_data (OAuth2PasswordRequestForm): The form data containing the                                            username and password  Returns:     Token: The access token
     * @summary Login For Access Token
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenicationApi
     */
    public loginForAccessTokenApiTokenPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: AxiosRequestConfig) {
        return AuthenicationApiFp(this.configuration).loginForAccessTokenApiTokenPost(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh the access token. This is used to refresh the access token before it expires.  Args:     current_user (User): The current user  Returns:     Token: The access token
     * @summary Refresh Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenicationApi
     */
    public refreshTokenApiTokenRefreshPost(options?: AxiosRequestConfig) {
        return AuthenicationApiFp(this.configuration).refreshTokenApiTokenRefreshPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChatApi - axios parameter creator
 * @export
 */
export const ChatApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new chat  Args:     chat (CreateChat): The chat to be created  Returns:     Chat: The created chat
         * @summary Create Chat
         * @param {string} artifactId 
         * @param {string} name 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChatApiChatsPost: async (artifactId: string, name: string, description?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('createChatApiChatsPost', 'artifactId', artifactId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createChatApiChatsPost', 'name', name)
            const localVarPath = `/api/chats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (artifactId !== undefined) {
                localVarQueryParameter['artifact_id'] = artifactId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the chat with the given id  Args:     chat (Chat): The chat to be deleted  Returns:     None
         * @summary Delete Chat Chatid
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChatChatidApiChatsChatIdDelete: async (chatId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('deleteChatChatidApiChatsChatIdDelete', 'chatId', chatId)
            const localVarPath = `/api/chats/{chat_id}`
                .replace(`{${"chat_id"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all chats of the current user.  Args:     current_user (User): The current user     db (Session): The database session  Returns:     None
         * @summary Delete Chats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChatsApiChatsDelete: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/chats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the chat with the given id  Args:     chat (Chat): The chat to be returned  Returns:     Chat: The chat with the given id
         * @summary Get Chat Chatid
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatChatidApiChatsChatIdGet: async (chatId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('getChatChatidApiChatsChatIdGet', 'chatId', chatId)
            const localVarPath = `/api/chats/{chat_id}`
                .replace(`{${"chat_id"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all the chats of the current user
         * @summary Get Chats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatsApiChatsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/chats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all messages from the given chat and applies filters, if any.  Args:     chat (Chat): The chat to be returned     request_options (RequestOptions): The request options  Returns:     MessagesResponse: The messages from the given chat and metadata.
         * @summary Get Chats Chatid Messages
         * @param {string} chatId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {boolean} [polling] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatsChatidMessagesApiChatsChatIdMessagesGet: async (chatId: string, limit?: number, offset?: number, fromDate?: string, toDate?: string, polling?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('getChatsChatidMessagesApiChatsChatIdMessagesGet', 'chatId', chatId)
            const localVarPath = `/api/chats/{chat_id}/messages`
                .replace(`{${"chat_id"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }

            if (polling !== undefined) {
                localVarQueryParameter['polling'] = polling;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the message with the given id of the chat with the given id  Args:     message (Message): The message to be returned  Returns:     Message: The message with the given id of the chat with the given id
         * @summary Get Chats Chatid Messages Messageid
         * @param {string} messageId 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatsChatidMessagesMessageidApiChatsChatIdMessagesMessageIdGet: async (messageId: string, chatId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('getChatsChatidMessagesMessageidApiChatsChatIdMessagesMessageIdGet', 'messageId', messageId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('getChatsChatidMessagesMessageidApiChatsChatIdMessagesMessageIdGet', 'chatId', chatId)
            const localVarPath = `/api/chats/{chat_id}/messages/{message_id}`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)))
                .replace(`{${"chat_id"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates chat\'s attributes like name, description, etc.  Args:     chat_updates (UpdateChat): The updates.     chat (Chat): The chat to be updated.     db (Session): Database session.  Returns (Chat): Updated chat.
         * @summary Patch Chat Chatid
         * @param {string} chatId 
         * @param {UpdateChat} updateChat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchChatChatidApiChatsChatIdPatch: async (chatId: string, updateChat: UpdateChat, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('patchChatChatidApiChatsChatIdPatch', 'chatId', chatId)
            // verify required parameter 'updateChat' is not null or undefined
            assertParamExists('patchChatChatidApiChatsChatIdPatch', 'updateChat', updateChat)
            const localVarPath = `/api/chats/{chat_id}`
                .replace(`{${"chat_id"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateChat, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new message in the chat with the given id  Args:     message (CreateMessage): The message to be created
         * @summary Post Chats Chatid Messages
         * @param {string} chatId 
         * @param {string} content 
         * @param {string} [artifactVersionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChatsChatidMessagesApiChatsChatIdMessagesPost: async (chatId: string, content: string, artifactVersionId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('postChatsChatidMessagesApiChatsChatIdMessagesPost', 'chatId', chatId)
            // verify required parameter 'content' is not null or undefined
            assertParamExists('postChatsChatidMessagesApiChatsChatIdMessagesPost', 'content', content)
            const localVarPath = `/api/chats/{chat_id}/messages`
                .replace(`{${"chat_id"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (content !== undefined) {
                localVarQueryParameter['content'] = content;
            }

            if (artifactVersionId !== undefined) {
                localVarQueryParameter['artifact_version_id'] = artifactVersionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Executes the message with the given id of the chat with the given id  Args:     message (Message): The message to be executed
         * @summary Post Chats Chatid Messages Messageid
         * @param {string} messageId 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChatsChatidMessagesMessageidApiChatsChatIdMessagesMessageIdExecutePost: async (messageId: string, chatId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('postChatsChatidMessagesMessageidApiChatsChatIdMessagesMessageIdExecutePost', 'messageId', messageId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('postChatsChatidMessagesMessageidApiChatsChatIdMessagesMessageIdExecutePost', 'chatId', chatId)
            const localVarPath = `/api/chats/{chat_id}/messages/{message_id}/execute`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)))
                .replace(`{${"chat_id"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatApi - functional programming interface
 * @export
 */
export const ChatApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new chat  Args:     chat (CreateChat): The chat to be created  Returns:     Chat: The created chat
         * @summary Create Chat
         * @param {string} artifactId 
         * @param {string} name 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChatApiChatsPost(artifactId: string, name: string, description?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Chat>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChatApiChatsPost(artifactId, name, description, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the chat with the given id  Args:     chat (Chat): The chat to be deleted  Returns:     None
         * @summary Delete Chat Chatid
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChatChatidApiChatsChatIdDelete(chatId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChatChatidApiChatsChatIdDelete(chatId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes all chats of the current user.  Args:     current_user (User): The current user     db (Session): The database session  Returns:     None
         * @summary Delete Chats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChatsApiChatsDelete(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChatsApiChatsDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the chat with the given id  Args:     chat (Chat): The chat to be returned  Returns:     Chat: The chat with the given id
         * @summary Get Chat Chatid
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatChatidApiChatsChatIdGet(chatId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Chat>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatChatidApiChatsChatIdGet(chatId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all the chats of the current user
         * @summary Get Chats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatsApiChatsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Chat>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatsApiChatsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all messages from the given chat and applies filters, if any.  Args:     chat (Chat): The chat to be returned     request_options (RequestOptions): The request options  Returns:     MessagesResponse: The messages from the given chat and metadata.
         * @summary Get Chats Chatid Messages
         * @param {string} chatId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {boolean} [polling] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatsChatidMessagesApiChatsChatIdMessagesGet(chatId: string, limit?: number, offset?: number, fromDate?: string, toDate?: string, polling?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatsChatidMessagesApiChatsChatIdMessagesGet(chatId, limit, offset, fromDate, toDate, polling, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the message with the given id of the chat with the given id  Args:     message (Message): The message to be returned  Returns:     Message: The message with the given id of the chat with the given id
         * @summary Get Chats Chatid Messages Messageid
         * @param {string} messageId 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatsChatidMessagesMessageidApiChatsChatIdMessagesMessageIdGet(messageId: string, chatId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatsChatidMessagesMessageidApiChatsChatIdMessagesMessageIdGet(messageId, chatId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates chat\'s attributes like name, description, etc.  Args:     chat_updates (UpdateChat): The updates.     chat (Chat): The chat to be updated.     db (Session): Database session.  Returns (Chat): Updated chat.
         * @summary Patch Chat Chatid
         * @param {string} chatId 
         * @param {UpdateChat} updateChat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchChatChatidApiChatsChatIdPatch(chatId: string, updateChat: UpdateChat, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Chat>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchChatChatidApiChatsChatIdPatch(chatId, updateChat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new message in the chat with the given id  Args:     message (CreateMessage): The message to be created
         * @summary Post Chats Chatid Messages
         * @param {string} chatId 
         * @param {string} content 
         * @param {string} [artifactVersionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postChatsChatidMessagesApiChatsChatIdMessagesPost(chatId: string, content: string, artifactVersionId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postChatsChatidMessagesApiChatsChatIdMessagesPost(chatId, content, artifactVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Executes the message with the given id of the chat with the given id  Args:     message (Message): The message to be executed
         * @summary Post Chats Chatid Messages Messageid
         * @param {string} messageId 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postChatsChatidMessagesMessageidApiChatsChatIdMessagesMessageIdExecutePost(messageId: string, chatId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postChatsChatidMessagesMessageidApiChatsChatIdMessagesMessageIdExecutePost(messageId, chatId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChatApi - factory interface
 * @export
 */
export const ChatApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatApiFp(configuration)
    return {
        /**
         * Creates a new chat  Args:     chat (CreateChat): The chat to be created  Returns:     Chat: The created chat
         * @summary Create Chat
         * @param {string} artifactId 
         * @param {string} name 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChatApiChatsPost(artifactId: string, name: string, description?: string, options?: any): AxiosPromise<Chat> {
            return localVarFp.createChatApiChatsPost(artifactId, name, description, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the chat with the given id  Args:     chat (Chat): The chat to be deleted  Returns:     None
         * @summary Delete Chat Chatid
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChatChatidApiChatsChatIdDelete(chatId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteChatChatidApiChatsChatIdDelete(chatId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes all chats of the current user.  Args:     current_user (User): The current user     db (Session): The database session  Returns:     None
         * @summary Delete Chats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChatsApiChatsDelete(options?: any): AxiosPromise<void> {
            return localVarFp.deleteChatsApiChatsDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the chat with the given id  Args:     chat (Chat): The chat to be returned  Returns:     Chat: The chat with the given id
         * @summary Get Chat Chatid
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatChatidApiChatsChatIdGet(chatId: string, options?: any): AxiosPromise<Chat> {
            return localVarFp.getChatChatidApiChatsChatIdGet(chatId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all the chats of the current user
         * @summary Get Chats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatsApiChatsGet(options?: any): AxiosPromise<Array<Chat>> {
            return localVarFp.getChatsApiChatsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all messages from the given chat and applies filters, if any.  Args:     chat (Chat): The chat to be returned     request_options (RequestOptions): The request options  Returns:     MessagesResponse: The messages from the given chat and metadata.
         * @summary Get Chats Chatid Messages
         * @param {string} chatId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {boolean} [polling] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatsChatidMessagesApiChatsChatIdMessagesGet(chatId: string, limit?: number, offset?: number, fromDate?: string, toDate?: string, polling?: boolean, options?: any): AxiosPromise<MessagesResponse> {
            return localVarFp.getChatsChatidMessagesApiChatsChatIdMessagesGet(chatId, limit, offset, fromDate, toDate, polling, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the message with the given id of the chat with the given id  Args:     message (Message): The message to be returned  Returns:     Message: The message with the given id of the chat with the given id
         * @summary Get Chats Chatid Messages Messageid
         * @param {string} messageId 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatsChatidMessagesMessageidApiChatsChatIdMessagesMessageIdGet(messageId: string, chatId: string, options?: any): AxiosPromise<Message> {
            return localVarFp.getChatsChatidMessagesMessageidApiChatsChatIdMessagesMessageIdGet(messageId, chatId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates chat\'s attributes like name, description, etc.  Args:     chat_updates (UpdateChat): The updates.     chat (Chat): The chat to be updated.     db (Session): Database session.  Returns (Chat): Updated chat.
         * @summary Patch Chat Chatid
         * @param {string} chatId 
         * @param {UpdateChat} updateChat 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchChatChatidApiChatsChatIdPatch(chatId: string, updateChat: UpdateChat, options?: any): AxiosPromise<Chat> {
            return localVarFp.patchChatChatidApiChatsChatIdPatch(chatId, updateChat, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new message in the chat with the given id  Args:     message (CreateMessage): The message to be created
         * @summary Post Chats Chatid Messages
         * @param {string} chatId 
         * @param {string} content 
         * @param {string} [artifactVersionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChatsChatidMessagesApiChatsChatIdMessagesPost(chatId: string, content: string, artifactVersionId?: string, options?: any): AxiosPromise<Message> {
            return localVarFp.postChatsChatidMessagesApiChatsChatIdMessagesPost(chatId, content, artifactVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Executes the message with the given id of the chat with the given id  Args:     message (Message): The message to be executed
         * @summary Post Chats Chatid Messages Messageid
         * @param {string} messageId 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChatsChatidMessagesMessageidApiChatsChatIdMessagesMessageIdExecutePost(messageId: string, chatId: string, options?: any): AxiosPromise<void> {
            return localVarFp.postChatsChatidMessagesMessageidApiChatsChatIdMessagesMessageIdExecutePost(messageId, chatId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChatApi - object-oriented interface
 * @export
 * @class ChatApi
 * @extends {BaseAPI}
 */
export class ChatApi extends BaseAPI {
    /**
     * Creates a new chat  Args:     chat (CreateChat): The chat to be created  Returns:     Chat: The created chat
     * @summary Create Chat
     * @param {string} artifactId 
     * @param {string} name 
     * @param {string} [description] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public createChatApiChatsPost(artifactId: string, name: string, description?: string, options?: AxiosRequestConfig) {
        return ChatApiFp(this.configuration).createChatApiChatsPost(artifactId, name, description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the chat with the given id  Args:     chat (Chat): The chat to be deleted  Returns:     None
     * @summary Delete Chat Chatid
     * @param {string} chatId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public deleteChatChatidApiChatsChatIdDelete(chatId: string, options?: AxiosRequestConfig) {
        return ChatApiFp(this.configuration).deleteChatChatidApiChatsChatIdDelete(chatId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes all chats of the current user.  Args:     current_user (User): The current user     db (Session): The database session  Returns:     None
     * @summary Delete Chats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public deleteChatsApiChatsDelete(options?: AxiosRequestConfig) {
        return ChatApiFp(this.configuration).deleteChatsApiChatsDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the chat with the given id  Args:     chat (Chat): The chat to be returned  Returns:     Chat: The chat with the given id
     * @summary Get Chat Chatid
     * @param {string} chatId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public getChatChatidApiChatsChatIdGet(chatId: string, options?: AxiosRequestConfig) {
        return ChatApiFp(this.configuration).getChatChatidApiChatsChatIdGet(chatId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all the chats of the current user
     * @summary Get Chats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public getChatsApiChatsGet(options?: AxiosRequestConfig) {
        return ChatApiFp(this.configuration).getChatsApiChatsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all messages from the given chat and applies filters, if any.  Args:     chat (Chat): The chat to be returned     request_options (RequestOptions): The request options  Returns:     MessagesResponse: The messages from the given chat and metadata.
     * @summary Get Chats Chatid Messages
     * @param {string} chatId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {boolean} [polling] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public getChatsChatidMessagesApiChatsChatIdMessagesGet(chatId: string, limit?: number, offset?: number, fromDate?: string, toDate?: string, polling?: boolean, options?: AxiosRequestConfig) {
        return ChatApiFp(this.configuration).getChatsChatidMessagesApiChatsChatIdMessagesGet(chatId, limit, offset, fromDate, toDate, polling, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the message with the given id of the chat with the given id  Args:     message (Message): The message to be returned  Returns:     Message: The message with the given id of the chat with the given id
     * @summary Get Chats Chatid Messages Messageid
     * @param {string} messageId 
     * @param {string} chatId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public getChatsChatidMessagesMessageidApiChatsChatIdMessagesMessageIdGet(messageId: string, chatId: string, options?: AxiosRequestConfig) {
        return ChatApiFp(this.configuration).getChatsChatidMessagesMessageidApiChatsChatIdMessagesMessageIdGet(messageId, chatId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates chat\'s attributes like name, description, etc.  Args:     chat_updates (UpdateChat): The updates.     chat (Chat): The chat to be updated.     db (Session): Database session.  Returns (Chat): Updated chat.
     * @summary Patch Chat Chatid
     * @param {string} chatId 
     * @param {UpdateChat} updateChat 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public patchChatChatidApiChatsChatIdPatch(chatId: string, updateChat: UpdateChat, options?: AxiosRequestConfig) {
        return ChatApiFp(this.configuration).patchChatChatidApiChatsChatIdPatch(chatId, updateChat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new message in the chat with the given id  Args:     message (CreateMessage): The message to be created
     * @summary Post Chats Chatid Messages
     * @param {string} chatId 
     * @param {string} content 
     * @param {string} [artifactVersionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public postChatsChatidMessagesApiChatsChatIdMessagesPost(chatId: string, content: string, artifactVersionId?: string, options?: AxiosRequestConfig) {
        return ChatApiFp(this.configuration).postChatsChatidMessagesApiChatsChatIdMessagesPost(chatId, content, artifactVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Executes the message with the given id of the chat with the given id  Args:     message (Message): The message to be executed
     * @summary Post Chats Chatid Messages Messageid
     * @param {string} messageId 
     * @param {string} chatId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public postChatsChatidMessagesMessageidApiChatsChatIdMessagesMessageIdExecutePost(messageId: string, chatId: string, options?: AxiosRequestConfig) {
        return ChatApiFp(this.configuration).postChatsChatidMessagesMessageidApiChatsChatIdMessagesMessageIdExecutePost(messageId, chatId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Users Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersMeApiUsersMeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Users Me Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersMeGroupsApiUsersMeGroupsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/me/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Users
         * @param {CreateUser} createUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersApiUsersPost: async (createUser: CreateUser, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUser' is not null or undefined
            assertParamExists('postUsersApiUsersPost', 'createUser', createUser)
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Users Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersMeApiUsersMeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersMeApiUsersMeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Users Me Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersMeGroupsApiUsersMeGroupsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersMeGroupsApiUsersMeGroupsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Users
         * @param {CreateUser} createUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersApiUsersPost(createUser: CreateUser, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsersApiUsersPost(createUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Users Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersMeApiUsersMeGet(options?: any): AxiosPromise<User> {
            return localVarFp.getUsersMeApiUsersMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Users Me Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersMeGroupsApiUsersMeGroupsGet(options?: any): AxiosPromise<GroupList> {
            return localVarFp.getUsersMeGroupsApiUsersMeGroupsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Users
         * @param {CreateUser} createUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersApiUsersPost(createUser: CreateUser, options?: any): AxiosPromise<User> {
            return localVarFp.postUsersApiUsersPost(createUser, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Get Users Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersMeApiUsersMeGet(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersMeApiUsersMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Users Me Groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersMeGroupsApiUsersMeGroupsGet(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersMeGroupsApiUsersMeGroupsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Users
     * @param {CreateUser} createUser 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUsersApiUsersPost(createUser: CreateUser, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).postUsersApiUsersPost(createUser, options).then((request) => request(this.axios, this.basePath));
    }
}


